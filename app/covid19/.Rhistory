mat <- matrix(NA, 10, 10)
mat
for (i in 1:10) {
for (j in 1:10) {
mat[i,j] <- abs(j - i)
}
}
mat
for (i in 1:10) {
for (j in 1:10) {
if(i == j) {
mat[i, j] <- 10 - i
}
}
}
mat
msleep %>% head()
library(dplyr)
.libPaths()
#
# This is the server logic of a Shiny web application. You can run the
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
#-------------------------------------------------App Server----------------------------------
library(viridis)
library(dplyr)
library(tibble)
library(tidyverse)
install.packages('tmap',lib = '/Users/liangshiting/Library/R/3.5/library')
library(tmap)
install.packages('tmap',lib = '/Users/liangshiting/Library/R/3.5/library')
library(tmap)
.libPaths()
install.packages('tmap',lib = "/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library(tmap)
--libdir=/usr/lib64
library(sf)
library(RCurl)
library(tmap)
install.packages('tmap',lib = "/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
install.packages("tmap", lib = "/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library(tmap)
#load('./output/covid-19.RData')
shinyServer(function(input, output) {
#----------------------------------------
#tab panel 1 - Home Plots
#preapare data for plot
output$case_overtime <- renderPlotly({
#determin the row index for subset
req(input$log_scale)
end_date_index <- which(date_choices == input$date)
#if log scale is not enabled, we will just use cases
if (input$log_scale == FALSE) {
#render plotly figure
case_fig <- plot_ly()
#add comfirmed case lines
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~as.numeric(aggre_cases[input$country,])[1:end_date_index],
line = list(color = 'rgba(67,67,67,1)', width = 2),
name = 'Confirmed Cases')
#add death line
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~as.numeric(aggre_death[input$country,])[1:end_date_index],
name = 'Death Toll')
#set the axis for the plot
case_fig <- case_fig %>%
layout(title = paste0(input$country,'\t','Trend'),
xaxis = list(title = 'Date',showgrid = FALSE),
yaxis = list(title = 'Comfirmed Cases/Deaths',showgrid=FALSE)
)
}
#if enable log scale, we need to take log of the y values
else{
#render plotly figure
case_fig <- plot_ly()
#add comfirmed case lines
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~log(as.numeric(aggre_cases[input$country,])[1:end_date_index]),
line = list(color = 'rgba(67,67,67,1)', width = 2),
name = 'Confirmed Cases')
#add death line
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~log(as.numeric(aggre_death[input$country,])[1:end_date_index]),
name = 'Death Toll')
#set the axis for the plot
case_fig <- case_fig %>%
layout(title = paste0(input$country,'<br>','\t','Trends'),
xaxis = list(title = 'Date',showgrid = FALSE),
yaxis = list(title = 'Comfirmed Cases/Deaths(Log Scale)',showgrid=FALSE)
)
}
return(case_fig)
})
#----------------------------------------
#tab panel 2 - Maps
data_countries <- reactive({
if(!is.null(input$choices)){
if(input$choices == "Cases"){
return(aggre_cases_copy)
}else{
return(aggre_death_copy)
}}
})
#get the largest number of count for better color assignment
maxTotal<- reactive(max(data_countries()%>%select_if(is.numeric), na.rm = T))
#color palette
pal <- reactive(colorNumeric(c("#FFFFFFFF" ,rev(inferno(256))), domain = c(0,log(binning(maxTotal())))))
output$map <- renderLeaflet({
map <-  leaflet(countries) %>%
addProviderTiles("Stadia.Outdoors", options = providerTileOptions(noWrap = TRUE)) %>%
setView(0, 30, zoom = 3) })
observe({
if(!is.null(input$date_map)){
select_date <- format.Date(input$date_map,'%Y-%m-%d')
}
if(input$choices == "Cases"){
#merge the spatial dataframe and cases dataframe
aggre_cases_join <- merge(countries,
data_countries(),
by.x = 'NAME',
by.y = 'country_names',sort = FALSE)
#pop up for polygons
country_popup <- paste0("<strong>Country: </strong>",
aggre_cases_join$NAME,
"<br><strong>",
"Total Cases: ",
aggre_cases_join[[select_date]],
"<br><strong>")
leafletProxy("map", data = aggre_cases_join)%>%
addPolygons(fillColor = pal()(log((aggre_cases_join[[select_date]])+1)),
layerId = ~NAME,
fillOpacity = 1,
color = "#BDBDC3",
weight = 1,
popup = country_popup)
} else {
#join the two dfs together
aggre_death_join<- merge(countries,
data_countries(),
by.x = 'NAME',
by.y = 'country_names',
sort = FALSE)
#pop up for polygons
country_popup <- paste0("<strong>Country: </strong>",
aggre_death_join$NAME,
"<br><strong>",
"Total Deaths: ",
aggre_death_join[[select_date]],
"<br><strong>")
leafletProxy("map", data = aggre_death_join)%>%
addPolygons(fillColor = pal()(log((aggre_death_join[[select_date]])+1)),
layerId = ~NAME,
fillOpacity = 1,
color = "#BDBDC3",
weight = 1,
popup = country_popup)
}
})
})
library(rgdal)
library(leaflet)
library(shiny)
library(shinythemes)
library(plotly)
library(ggplot2)
#can run RData directly to get the necessary date for the app
#global.r will enable us to get new data everyday
#update data with automated script
source("global.R")
#load('./output/covid-19.RData')
shinyServer(function(input, output) {
#----------------------------------------
#tab panel 1 - Home Plots
#preapare data for plot
output$case_overtime <- renderPlotly({
#determin the row index for subset
req(input$log_scale)
end_date_index <- which(date_choices == input$date)
#if log scale is not enabled, we will just use cases
if (input$log_scale == FALSE) {
#render plotly figure
case_fig <- plot_ly()
#add comfirmed case lines
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~as.numeric(aggre_cases[input$country,])[1:end_date_index],
line = list(color = 'rgba(67,67,67,1)', width = 2),
name = 'Confirmed Cases')
#add death line
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~as.numeric(aggre_death[input$country,])[1:end_date_index],
name = 'Death Toll')
#set the axis for the plot
case_fig <- case_fig %>%
layout(title = paste0(input$country,'\t','Trend'),
xaxis = list(title = 'Date',showgrid = FALSE),
yaxis = list(title = 'Comfirmed Cases/Deaths',showgrid=FALSE)
)
}
#if enable log scale, we need to take log of the y values
else{
#render plotly figure
case_fig <- plot_ly()
#add comfirmed case lines
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~log(as.numeric(aggre_cases[input$country,])[1:end_date_index]),
line = list(color = 'rgba(67,67,67,1)', width = 2),
name = 'Confirmed Cases')
#add death line
case_fig <- case_fig %>% add_lines(x = ~date_choices[1:end_date_index],
y = ~log(as.numeric(aggre_death[input$country,])[1:end_date_index]),
name = 'Death Toll')
#set the axis for the plot
case_fig <- case_fig %>%
layout(title = paste0(input$country,'<br>','\t','Trends'),
xaxis = list(title = 'Date',showgrid = FALSE),
yaxis = list(title = 'Comfirmed Cases/Deaths(Log Scale)',showgrid=FALSE)
)
}
return(case_fig)
})
#----------------------------------------
#tab panel 2 - Maps
data_countries <- reactive({
if(!is.null(input$choices)){
if(input$choices == "Cases"){
return(aggre_cases_copy)
}else{
return(aggre_death_copy)
}}
})
#get the largest number of count for better color assignment
maxTotal<- reactive(max(data_countries()%>%select_if(is.numeric), na.rm = T))
#color palette
pal <- reactive(colorNumeric(c("#FFFFFFFF" ,rev(inferno(256))), domain = c(0,log(binning(maxTotal())))))
output$map <- renderLeaflet({
map <-  leaflet(countries) %>%
addProviderTiles("Stadia.Outdoors", options = providerTileOptions(noWrap = TRUE)) %>%
setView(0, 30, zoom = 3) })
observe({
if(!is.null(input$date_map)){
select_date <- format.Date(input$date_map,'%Y-%m-%d')
}
if(input$choices == "Cases"){
#merge the spatial dataframe and cases dataframe
aggre_cases_join <- merge(countries,
data_countries(),
by.x = 'NAME',
by.y = 'country_names',sort = FALSE)
#pop up for polygons
country_popup <- paste0("<strong>Country: </strong>",
aggre_cases_join$NAME,
"<br><strong>",
"Total Cases: ",
aggre_cases_join[[select_date]],
"<br><strong>")
leafletProxy("map", data = aggre_cases_join)%>%
addPolygons(fillColor = pal()(log((aggre_cases_join[[select_date]])+1)),
layerId = ~NAME,
fillOpacity = 1,
color = "#BDBDC3",
weight = 1,
popup = country_popup)
} else {
#join the two dfs together
aggre_death_join<- merge(countries,
data_countries(),
by.x = 'NAME',
by.y = 'country_names',
sort = FALSE)
#pop up for polygons
country_popup <- paste0("<strong>Country: </strong>",
aggre_death_join$NAME,
"<br><strong>",
"Total Deaths: ",
aggre_death_join[[select_date]],
"<br><strong>")
leafletProxy("map", data = aggre_death_join)%>%
addPolygons(fillColor = pal()(log((aggre_death_join[[select_date]])+1)),
layerId = ~NAME,
fillOpacity = 1,
color = "#BDBDC3",
weight = 1,
popup = country_popup)
}
})
})
#
# This is the user-interface definition of a Shiny web application. You can
# run the application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
#ag
#    http://shiny.rstudio.com/
#
# Define UI for application that draws a histogram
library(viridis)
library(dplyr)
library(tibble)
library(tidyverse)
library(shinythemes)
library(sf)
library(RCurl)
library(tmap)
library(rgdal)
library(leaflet)
library(shiny)
library(shinythemes)
library(plotly)
library(ggplot2)
#load('./output/covid-19.RData')
shinyUI(navbarPage(title = 'COVID-19',
fluid = TRUE,
collapsible = TRUE,
#Select whichever theme works for the app
theme = shinytheme("journal"),
#--------------------------
#tab panel 1 - Home
tabPanel("Home",icon = icon("home"),
fluidPage(
fluidRow(
column(12,
h1("Global Cases overview across time"),
fluidRow(
#select the date until now
column(6,
sliderInput('date','Date Unitl:',
#first day of data recording
min = as.Date(date_choices[1]),
#present day of data recording
max = as.Date(tail(date_choices,1)),
value = as.Date(date_choices[1]),
timeFormat = "%Y-%m-%d",
animate = TRUE, step = 5),
fluidRow(
#select the country we want to see the trend
column(6,
selectInput('country','Which Country?',
choices = country_names_choices,
selected = 'United States of America')),
#select whether want case number in log-scale or not
column(6,
radioButtons("log_scale", "In Log Scale:",
choices = c(TRUE,FALSE),
selected = FALSE))
)
),
#render plotly output
column(width = 6,
plotlyOutput('case_overtime'))
)
)
)
)
),
#--------------------------
#tab panel 2 - Map
tabPanel("Maps",icon = icon("map-marker-alt"),div(class = 'outer',
leafletOutput("map", width = "100%", height = "1200"),
absolutePanel(id = "control", class = "panel panel-default", fixed = TRUE, draggable = TRUE,
top = 300, left = 20, right = "auto", bottom = "auto", width = 250, height = "auto",
selectInput('choices','Which data to visualize:',
choices = c('Cases','Death'),
selected = c('Cases')),
sliderInput('date_map','Input Date:',
#first day of data recording
min = as.Date(date_choices[1]),
#present day of data recording
max = as.Date(tail(date_choices,1)),
value = as.Date('2020-04-01','%Y-%m-%d'),
timeFormat = "%Y-%m-%d",
animate = TRUE, step = 5),
style = "opacity: 0.80"))),
# ----------------------------------
#tab panel 3 - Source
tabPanel("Data Source",icon = icon("cloud-download"),
HTML(
"<h2> Data Source : </h2>
<h4> <p><li><a href='https://coronavirus.jhu.edu/map.html'>Coronavirus COVID-19 Global Cases map Johns Hopkins University</a></li></h4>
<h4><li>COVID-19 Cases : <a href='https://github.com/CSSEGISandData/COVID-19' target='_blank'>Github Johns Hopkins University</a></li></h4>
<h4><li>Spatial Polygons : <a href='https://www.naturalearthdata.com/downloads/' target='_blank'> Natural Earth</a></li></h4>"
))
))
if (!require("tmap")) {
install.packages("tmap")
library(tmap)
}
install.packages("tmap")
data_transformer <- function(df) {
#################################################################
##Given dataframe tranform the dataframe into aggregate level with
##rownames equal to countries name, and colnames equals date
#################################################################
#clean the country/regionnames
df <- data_cooker(df)
#columns that don't need
not_select_cols <- c("Province.State","Lat","Long")
#aggregate the province into country level
aggre_df <- df %>% group_by(Country.Region) %>%
select(-one_of(not_select_cols)) %>% summarise_all(sum)
#assign the country name into row names
aggre_df <- aggre_df %>% remove_rownames %>%
tibble::column_to_rownames(var="Country.Region")
#change the colume name into date format
date_name <- colnames(aggre_df)
#change e.g: "x1.22.20" -> "2020-01-22"
date_choices <- as.Date(date_name,format = 'X%m.%d.%y')
#assign column nam
colnames(aggre_df) <- date_choices
return(aggre_df)
}
#--------------------------------------------------------------------
###############################Data Preparation#######################
#Data Sources
"Dong E, Du H, Gardner L. An interactive web-based dashboard to track COVID-19 in real time.
Lancet Inf Dis. 20(5):533-534. doi: 10.1016/S1473-3099(20)30120-1"
#get the daily global cases data from API
Cases_URL <- getURL("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")
global_cases <- read.csv(text = Cases_URL)
#get the daily global deaths data from API
Death_URL <- getURL("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")
global_death <- read.csv(text = Death_URL)
#get aggregate cases
aggre_cases <- as.data.frame(data_transformer(global_cases))
function(df) {
#################################################################
##Given dataframe tranform the dataframe into aggregate level with
##rownames equal to countries name, and colnames equals date
#################################################################
#clean the country/regionnames
df <- data_cooker(df)
#columns that don't need
not_select_cols <- c("Province.State","Lat","Long")
#aggregate the province into country level
aggre_df <- df %>% group_by(Country.Region) %>%
select(-one_of(not_select_cols)) %>% summarise_all(sum)
#assign the country name into row names
aggre_df <- aggre_df %>% remove_rownames %>%
tibble::column_to_rownames(var="Country.Region")
#change the colume name into date format
date_name <- colnames(aggre_df)
#change e.g: "x1.22.20" -> "2020-01-22"
date_choices <- as.Date(date_name,format = 'X%m.%d.%y')
#assign column nam
colnames(aggre_df) <- date_choices
return(aggre_df)
}
#get aggregate cases
aggre_cases <- as.data.frame(data_transformer(global_cases))
#get aggregate cases
aggre_cases <- as.data.frame(data_transformer(global_cases))
#get aggregate cases
aggre_cases <- as.data.frame(data_transformer(global_cases))
install.packages('tmap')
install.packages("tmap")
install.packages(sf)
install.packages('sf')
install.packages("stars")
install.packages("tmaptools")
library(tmaptools)
library('tmap')
install.packages('tmap')
set --libdir=/usr/lib64
make install rhome=/usr/lib64
install.packages('stars')
library(sf)
library(sf)
library(RCurl)
library(tmap)
library(tmap)
library(sf)
library(RCurl)
library(tmap)
library(rgdal)
library(tmap)
install.packages('star')
install.packages('stars')
install.packages("stars")
version
shiny::runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
runApp()
runApp('Documents/GitHub/Fall2020-Project2-group5/app/covid19')
save(df_clean, file="output/data_up_to_date.RData")
rm(df)
source('~/Documents/GitHub/Fall2020-Project2-group5/app/covid19/global_citina.R', echo=TRUE)
# save(df_clean, file="output/data_up_to_date.RData")
load("output/data_up_to_date.RData")
source('~/Documents/GitHub/Fall2020-Project2-group5/app/covid19/global_citina.R', echo=TRUE)
# save(df_clean, file="output/data_up_to_date.RData")
load("../covid/output/data_up_to_date.RData")
getwd()
setwd("~/Documents/GitHub/Fall2020-Project2-group5/app/covid19")
# save(df_clean, file="output/data_up_to_date.RData")
load("../covid/output/data_up_to_date.RData")
# save(df_clean, file="output/data_up_to_date.RData")
load("output/data_up_to_date.RData")
runApp()
setwd("~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/dac3bb941f4a2e509ccb26bd85458409/Message/MessageTemp/96f750e2bc9a3aad69014e32a497cb77/File/map/map")
runApp()
runApp()
runApp()
View(df_clean)
View(df_clean)
View(temp)
runApp('~/Documents/GitHub/Fall2020-Project2-group5/app/covid19')
